mod bar_items;
mod commands;
mod completions;
mod config;
mod connection;
mod debug;
mod render;
mod room;
mod server;
mod utils;

use std::{
    cell::{Ref, RefCell},
    collections::HashMap,
    path::{Path, PathBuf},
    rc::Rc,
};

use futures::future::BoxFuture;
use matrix_sdk::async_trait;
use opentelemetry::{
    sdk::{
        export::trace::ExportResult,
        trace::{BatchMessage, TraceRuntime},
        util::tokio_interval_stream,
    },
    trace::TraceError,
};
use opentelemetry_contrib::trace::exporter::jaeger_json::JaegerJsonRuntime;
use tokio::runtime::{Handle, Runtime};
use tracing_chrome::FlushGuard;
use tracing_subscriber::layer::SubscriberExt;

use weechat::{
    buffer::{Buffer, BufferHandle},
    hooks::{SignalCallback, SignalData, SignalHook},
    plugin, Args, Plugin, ReturnCode, Weechat,
};

use crate::{
    bar_items::BarItems, commands::Commands, completions::Completions,
    config::ConfigHandle, room::RoomHandle, server::MatrixServer,
};

const PLUGIN_NAME: &str = "matrix";

#[derive(Clone, Debug)]
pub struct Servers {
    inner: Rc<RefCell<HashMap<String, MatrixServer>>>,
    runtime: Handle,
}

#[allow(clippy::large_enum_variant)]
pub enum BufferOwner {
    Server(MatrixServer),
    Room(MatrixServer, RoomHandle),
    None,
}

#[derive(Clone, Debug)]
struct Foo {
    runtime: Handle,
}

impl opentelemetry::runtime::Runtime for Foo {
    type Interval = tokio_stream::wrappers::IntervalStream;
    type Delay = tokio::task::JoinHandle<()>;

    fn interval(&self, duration: std::time::Duration) -> Self::Interval {
        tokio_interval_stream(duration)
    }

    fn spawn(&self, future: BoxFuture<'static, ()>) {
        self.runtime.spawn(future);
    }

    fn delay(&self, duration: std::time::Duration) -> Self::Delay {
        let handle = self.runtime.spawn(tokio::time::sleep(duration));

        handle
    }
}

impl TraceRuntime for Foo {
    type Receiver = tokio_stream::wrappers::ReceiverStream<BatchMessage>;
    type Sender = tokio::sync::mpsc::Sender<BatchMessage>;

    fn batch_message_channel(
        &self,
        capacity: usize,
    ) -> (Self::Sender, Self::Receiver) {
        let (sender, receiver) = tokio::sync::mpsc::channel(capacity);
        (
            sender,
            tokio_stream::wrappers::ReceiverStream::new(receiver),
        )
    }
}

#[async_trait]
impl JaegerJsonRuntime for Foo {
    async fn create_dir(&self, path: &Path) -> ExportResult {
        let path = path.to_owned();

        let handle = self.runtime.spawn(async move {
            if tokio::fs::metadata(&path).await.is_err() {
                tokio::fs::create_dir_all(path)
                    .await
                    .map_err(|e| TraceError::Other(Box::new(e)))
            } else {
                Ok(())
            }
        });

        handle.await.unwrap()?;

        Ok(())
    }

    async fn write_to_file(&self, path: &Path, content: &[u8]) -> ExportResult {
        use tokio::io::AsyncWriteExt;
        let path = path.to_owned();
        let content = content.to_owned();

        let handle = tokio::spawn(async move {
            let mut file = tokio::fs::File::create(path)
                .await
                .map_err(|e| TraceError::Other(Box::new(e)))?;
            file.write_all(&content)
                .await
                .map_err(|e| TraceError::Other(Box::new(e)))?;
            file.sync_data()
                .await
                .map_err(|e| TraceError::Other(Box::new(e)))?;
            Ok::<(), TraceError>(())
        });

        handle.await.unwrap()?;

        Ok(())
    }
}

impl BufferOwner {
    fn into_server(self) -> Option<MatrixServer> {
        match self {
            BufferOwner::Server(s) => Some(s),
            BufferOwner::Room(s, _) => Some(s),
            BufferOwner::None => None,
        }
    }

    fn into_room(self) -> Option<RoomHandle> {
        if let BufferOwner::Room(_, r) = self {
            Some(r)
        } else {
            None
        }
    }
}

impl Servers {
    fn new(handle: tokio::runtime::Handle) -> Self {
        Servers {
            inner: Rc::new(RefCell::new(HashMap::new())),
            runtime: handle,
        }
    }

    fn borrow(&self) -> Ref<'_, HashMap<String, MatrixServer>> {
        self.inner.borrow()
    }

    pub fn runtime(&self) -> &Handle {
        &self.runtime
    }

    pub fn is_empty(&self) -> bool {
        self.inner.borrow().is_empty()
    }

    pub fn contains(&self, server_name: &str) -> bool {
        self.inner.borrow().contains_key(server_name)
    }

    pub fn clear(&self) {
        self.inner.borrow_mut().clear();
    }

    pub fn insert(&self, server: MatrixServer) {
        self.inner
            .borrow_mut()
            .insert(server.name().to_string(), server);
    }

    pub fn get(&self, server_name: &str) -> Option<MatrixServer> {
        self.inner.borrow().get(server_name).cloned()
    }

    pub fn remove(&self, server_name: &str) -> Option<MatrixServer> {
        self.inner.borrow_mut().remove(server_name)
    }

    pub fn buffer_owner(&self, buffer: &Buffer) -> BufferOwner {
        let servers = self.borrow();

        for server in servers.values() {
            if let Some(b) = &*server.server_buffer() {
                if b.upgrade().map_or(false, |b| &b == buffer) {
                    return BufferOwner::Server(server.clone());
                }
            }

            for room in server.rooms() {
                let buffer_handle = room.buffer_handle();

                if let Ok(b) = buffer_handle.upgrade() {
                    if buffer == &b {
                        return BufferOwner::Room(server.clone(), room);
                    }
                }
            }
        }

        BufferOwner::None
    }

    /// Find a `MatrixServer` that the given buffer belongs to.
    ///
    /// Returns None if the buffer doesn't belong to any of our servers of
    /// rooms.
    pub fn find_server(&self, buffer: &Buffer) -> Option<MatrixServer> {
        self.buffer_owner(buffer).into_server()
    }

    /// Find a `RoomHandle` that the given buffer belongs to.
    ///
    /// Returns None if the buffer doesn't belong to any of our servers of
    /// rooms.
    pub fn find_room(&self, buffer: &Buffer) -> Option<RoomHandle> {
        self.buffer_owner(buffer).into_room()
    }
}

impl SignalCallback for Servers {
    fn callback(
        &mut self,
        _: &Weechat,
        _signal_name: &str,
        data: Option<SignalData>,
    ) -> ReturnCode {
        if let Some(SignalData::Buffer(buffer)) = data {
            if let Some(room) = self.find_room(&buffer) {
                room.update_typing_notice();
            }
        }
        ReturnCode::Ok
    }
}

struct Matrix {
    #[allow(dead_code)]
    global_runtime: Runtime,
    servers: Servers,
    #[allow(dead_code)]
    commands: Commands,
    config: ConfigHandle,
    #[allow(dead_code)]
    bar_items: BarItems,
    #[allow(dead_code)]
    typing_notice_signal: SignalHook,
    #[allow(dead_code)]
    completions: Completions,
    debug_buffer: RefCell<Option<BufferHandle>>,
    flush_guard: FlushGuard,
}

impl std::fmt::Debug for Matrix {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("Matrix");
        fmt.field("servers", &self.servers).finish()
    }
}

impl Matrix {
    fn autoconnect(servers: &HashMap<String, MatrixServer>) {
        for server in servers.values() {
            if server.autoconnect() {
                match server.connect() {
                    Ok(_) => (),
                    Err(e) => Weechat::print(&format!("{:?}", e)),
                }
            }
        }
    }

    fn create_default_server(servers: Servers, config: &ConfigHandle) {
        // TODO change this to matrix.org.
        let server_name = "localhost";

        let mut config_borrow = config.borrow_mut();
        let mut section = config_borrow
            .search_section_mut("server")
            .expect("Can't get server section");

        let server = MatrixServer::new(
            server_name,
            config,
            &mut section,
            servers.clone(),
        );
        servers.insert(server);
    }
}

impl Plugin for Matrix {
    fn init(_: &Weechat, _args: Args) -> Result<Self, ()> {
        let global_runtime =
            Runtime::new().expect("Couldn't create a new global runtime");

        let servers = Servers::new(global_runtime.handle().to_owned());
        let config = ConfigHandle::new(&servers);
        let commands = Commands::hook_all(&servers, &config)?;

        let bar_items = BarItems::hook_all(servers.clone())?;
        let completions = Completions::hook_all(servers.clone())?;

        let subscriber = tracing_subscriber::registry()
            .with(tracing_subscriber::filter::EnvFilter::from_default_env())
            .with(
                tracing_subscriber::fmt::layer()
                    .with_writer(debug::Debug)
                    .pretty(),
            );

        #[cfg(feature = "jaeger")]
        let subscriber = {
            let path = PathBuf::from("/home/poljar/jaeger-json-test");

            let foo = Foo {
                runtime: global_runtime.handle().to_owned(),
            };

            let handle = global_runtime.spawn_blocking(|| {
                opentelemetry_contrib::trace::exporter::jaeger_json::JaegerJsonExporter::new(
                    path,
                    "foo".to_owned(),
                    "weechat-matrix".to_owned(),
                    foo,
                ).install_batch()
            });

            let tracer = global_runtime.block_on(handle).unwrap();

            // let tracer = opentelemetry_jaeger::new_agent_pipeline()
            //     .with_service_name("weechat-matrix")
            //     .install_simple()
            //     .expect("Can't install jaeger pipeline");

            let telemetry = tracing_opentelemetry::layer().with_tracer(tracer);
            let subscriber = subscriber.with(telemetry);

            subscriber
        };

        let (chrome_layer, guard) =
            tracing_chrome::ChromeLayerBuilder::new().build();
        let subscriber = subscriber.with(chrome_layer);

        let _ = tracing::subscriber::set_global_default(subscriber).map_err(
            |_err| Weechat::print("Unable to set global default subscriber"),
        );

        {
            let config_borrow = config.borrow();
            if config_borrow.read().is_err() {
                return Err(());
            }
        }

        if servers.is_empty() {
            Matrix::create_default_server(servers.clone(), &config)
        }

        let typing = SignalHook::new("input_text_changed", servers.clone())
            .expect("Can't create signal hook for the typing notice cb");

        let plugin = Matrix {
            global_runtime,
            servers: servers.clone(),
            commands,
            config,
            bar_items,
            completions,
            debug_buffer: RefCell::new(None),
            typing_notice_signal: typing,
            flush_guard: guard,
        };

        Weechat::spawn(async move {
            let servers = servers.borrow();
            Matrix::autoconnect(&servers);
        })
        .detach();

        Ok(plugin)
    }
}

impl Drop for Matrix {
    fn drop(&mut self) {
        let servers = self.servers.borrow();

        // Buffer close callbacks get called after this, so disconnect here so
        // we don't leave all our rooms.
        //
        // TODO set a flag on the server as well so we don't even try to leave
        // the rooms, once leaving the rooms is implemented when the buffer gets
        // closed.
        for server in servers.values() {
            server.disconnect();
        }

        drop(servers);

        self.servers.clear();
    }
}

plugin!(
    Matrix,
    name: "matrix",
    author: "Damir JeliÄ‡ <poljar@termina.org.uk>",
    description: "Matrix protocol",
    version: "0.1.0",
    license: "ISC"
);
